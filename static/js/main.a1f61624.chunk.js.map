{"version":3,"sources":["components/ginger/ginger.model.ts","utils/geometry-parser.ts","components/ginger/ginger.utils.ts","components/ginger/ginger.component.tsx","components/speech-synthesis/speech-synthesis.model.ts","utils/storage-wrapper.ts","components/speech-synthesis/speech-synthesis.utils.ts","components/speech-synthesis/speech-synthesis.component.tsx","app.model.ts","app.tsx","index.tsx"],"names":["GINGER_MORPH_RANGES","Map","GINGER_MORPH_DESCRIPTORS","targets","thresholds","GINGER_EYES_POSITION","GeometryParser","json","geometry","isBitSet","value","position","parseModel","scale","faces","vertices","normals","colors","nUvLayers","undefined","uvs","i","length","faceVertexUvs","offset","zLength","vertex","Vector3","x","y","z","push","type","isQuad","hasMaterial","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","hasFaceVertexColor","faceAA","faceAB","faceAC","faceA","Face3","faceBA","faceBB","faceBC","faceB","materialIndex","fi","uvLayer","j","uvIndex","u","v","uv","Vector2","normalIndex","normal","set","copy","vertexNormals","hex","color","setHex","vertexColors","Color","a","b","c","face","colorIndex","parseSkin","influencesPerVertex","skinWeights","l","w","Vector4","skinIndices","d","bones","console","warn","animation","animations","parseMorphing","morphTargets","name","dstVertices","srcVertices","vl","parse","computeFaceNormals","computeBoundingSphere","BufferGeometry","fromGeometry","this","Geometry","getEnvironment","scene","Scene","containerWidth","window","innerWidth","containerHeight","innerHeight","aspect","camera","PerspectiveCamera","renderer","WebGLRenderer","antialias","preserveDrawingBuffer","setSize","directionalLight","DirectionalLight","add","getResources","modelNames","Promise","all","map","modelName","axios","get","then","data","jsonData","meshes","index","material","MeshLambertMaterial","mesh","Mesh","TextureLoader","loadAsync","texture","forEach","object3d","traverse","child","animate","dto","mousePositionRef","eyes","current","mousePositionVector","unproject","direction","sub","normalize","distance","clone","multiplyScalar","eye","lookAt","rotation","render","requestAnimationFrame","getMorphValue","target","normalizedValue","min","handleMeshMorphing","descriptor","morphValue","targetIndex","morphTargetInfluences","Math","abs","GingerComponent","morphControls","rendererRef","createRef","useState","isLoading","setIsLoading","isError","setIsError","headMesh","setHeadMesh","tongueMesh","setTongueMesh","teethBotMesh","setTeethBotMesh","useRef","animationFrameIdRef","updateMousePosition","event","clientX","clientY","useEffect","leftEye","rightEye","head","headBand","headPhones","teethTop","teethBot","tongue","applyMatrix4","Matrix4","makeTranslation","appendChild","domElement","document","addEventListener","setup","cancelAnimationFrame","removeEventListener","jawHeight","lipSync","updateMorphPoints","className","id","ref","VOWELS","Set","StorageWrapper","key","prefix","localStorage","setItem","getKey","getItem","initWordDescriptors","text","split","word","clearWord","replace","toLowerCase","ipaSyllables","timestamps","getSyllablesFromDictionary","syllables","restoredData","JSON","dictionaryUrl","response","findIndex","hwi","prs","hw","mw","headword","stringify","setupSyllables","descriptors","nextDescriptors","cloneDeep","words","uniqueWords","Array","from","values","syllablesFromDictionary","wordIndex","indexOf","getIpaVowel","syllable","matches","vowel","includes","maxLengthMatch","match","isTextReadable","nonReadable","isReadable","reduce","acc","curr","isCurrWordReadable","getVoices","resolve","voices","speechSynthesis","isEnglishVoice","voice","lang","getVoice","ziraVoice","find","englishFemaleVoice","toLocaleLowerCase","setupElapsedTime","rate","join","dryRunUtterance","SpeechSynthesisUtterance","pivots","volume","charIndex","charLength","elapsedTime","anchor","pivot","syllableDuration","speak","formTimeline","observables","timer","pipe","merge","SpeechSynthesisComponent","onVowelSpoken","onSpeechEnded","setText","isInputTouched","setIsInputTouched","isInputValid","setIsInputValid","isInputDisabled","setIsInputDisabled","status","setStatus","setVoice","getIsInputValid","inputValue","targetVoice","onTextInputKeyPress","test","wordDescriptors","utterance","timeline","timelineSubscription","Subscription","startTimeline","subscribe","stopTimeline","unsubscribe","classnames","invalid","disabled","placeholder","onChange","textEntered","onKeyPress","MORPH_TARGETS_MAP","AppComponent","initialMorphControls","setMorphControls","updateMorphControls","useCallback","controls","resetMorphControls","ReactDOM","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.a1f61624.chunk.js","sourcesContent":["import { MutableRefObject } from 'react';\nimport {\n  Camera, Mesh, Renderer, Scene,\n} from 'three';\n\nexport type GingerControl = 'jawHeight' | 'lipSync';\n\nexport type GingerMorphTarget =\n  | 'eyes'\n  | 'eyeLookSide'\n  | 'expression'\n  | 'jawHeight'\n  | 'jawTwist'\n  | 'lipCurl'\n  | 'lipSync'\n  | 'symmetry'\n  | 'sex'\n  | 'tongue'\n  | 'tongueDown'\n  | 'tongueTwist'\n  | 'teethOpenBot'\n  | 'teethOpenTop'\n  | 'teethSideBot'\n  | 'teethSideTop'\n  | 'width';\n\nexport interface GingerProps {\n  morphControls: {\n    [K in GingerControl]: number;\n  };\n}\n\nexport interface GingerMorphDescriptor {\n  targets: number[];\n  thresholds: number[];\n}\n\nexport interface MousePosition {\n  x: number;\n  y: number;\n}\n\nexport interface GingerAnimateDto {\n  renderer: Renderer;\n  scene: Scene;\n  camera: Camera;\n  eyes: Mesh[];\n  mousePositionRef: MutableRefObject<MousePosition>;\n}\n\nexport const GINGER_MORPH_RANGES = new Map<GingerMorphTarget, [number, number]>(\n  [\n    ['eyes', [-1, 1]],\n    ['expression', [-1, 1]],\n    ['jawHeight', [0, 1]],\n    ['jawTwist', [-1, 1]],\n    ['lipCurl', [-1, 1]],\n    ['lipSync', [-1, 1]],\n    ['symmetry', [0, 1]],\n    ['tongue', [0, 1]],\n    ['width', [-1, 1]],\n  ],\n);\n\nexport const GINGER_MORPH_DESCRIPTORS = new Map<\nGingerMorphTarget,\nGingerMorphDescriptor\n>([\n  [\n    'eyes',\n    {\n      targets: [0, 1, 7, 8],\n      thresholds: [-1, 0, 0, 0.1],\n    },\n  ],\n  [\n    'eyeLookSide',\n    {\n      targets: [2, 3],\n      thresholds: [-1, 0],\n    },\n  ],\n  [\n    'expression',\n    {\n      targets: [20, 9],\n      thresholds: [-1, 0],\n    },\n  ],\n  [\n    'jawHeight',\n    {\n      targets: [10, 11],\n      thresholds: [0, 0],\n    },\n  ],\n  [\n    'jawTwist',\n    {\n      targets: [12, 13],\n      thresholds: [-1, 0],\n    },\n  ],\n  [\n    'lipCurl',\n    {\n      targets: [15, 16],\n      thresholds: [-1, 0],\n    },\n  ],\n  [\n    'lipSync',\n    {\n      targets: [17, 18, 19],\n      thresholds: [-1, 0, 0.5],\n    },\n  ],\n  [\n    'symmetry',\n    {\n      targets: [14],\n      thresholds: [0],\n    },\n  ],\n  [\n    'sex',\n    {\n      targets: [22],\n      thresholds: [0],\n    },\n  ],\n  [\n    'tongue',\n    {\n      targets: [4],\n      thresholds: [0],\n    },\n  ],\n  [\n    'tongueDown',\n    {\n      targets: [1],\n      thresholds: [0],\n    },\n  ],\n  [\n    'tongueTwist',\n    {\n      targets: [2, 3],\n      thresholds: [-1, 0],\n    },\n  ],\n  [\n    'teethOpenBot',\n    {\n      targets: [3, 0],\n      thresholds: [0, 0],\n    },\n  ],\n  [\n    'teethOpenTop',\n    {\n      targets: [3, 0],\n      thresholds: [0, 0],\n    },\n  ],\n  [\n    'teethSideBot',\n    {\n      targets: [1, 2],\n      thresholds: [-1, 0],\n    },\n  ],\n  [\n    'teethSideTop',\n    {\n      targets: [1, 2],\n      thresholds: [-1, 0],\n    },\n  ],\n  [\n    'width',\n    {\n      targets: [23, 24],\n      thresholds: [-1, 0],\n    },\n  ],\n]);\n\nexport const GINGER_EYES_POSITION = [\n  [0.96, 6.169, 1.305],\n  [-0.96, 6.169, 1.305],\n];\n","/* eslint-disable no-plusplus */\n\nimport {\n  Geometry,\n  Vector3,\n  Face3,\n  Vector2,\n  Color,\n  Vector4,\n  Bone,\n  AnimationClip,\n  BufferGeometry,\n} from 'three';\n\nexport interface GeometryDescriptor {\n  geometry: BufferGeometry;\n}\n\nexport interface MorphTarget {\n  name: string;\n  vertices: number[];\n}\n\nexport interface MaterialDescriptor {\n  DbgColor: number;\n  DbgIndex: number;\n  DbgName: string;\n}\n\nexport interface GeometryJSON {\n  faces: number[];\n  vertices: number[];\n  normals: number[];\n  colors: any[];\n  scale?: number;\n  uvs?: number[][];\n  influencesPerVertex?: number;\n  skinWeights?: number[];\n  skinIndices?: number[];\n  bones?: Bone[];\n  animation?: AnimationClip;\n  animations?: AnimationClip[];\n  morphTargets?: MorphTarget[];\n  materials?: MaterialDescriptor[];\n}\n\n/**\n * This is (slightly cleaned up) code from THREE.JSONLoader.\n *\n * The thing is, we got 3D model in Three.js JSON Geometry format v3.1,\n * which, at the time of writing (October 2020), is not supported for\n * at least 3 years. We were not able to find a tool for converting\n * v3 to v4 (actual atm), and we have doubts that this is even possible.\n * We tried converting the model to OBJ format, and that worked fine,\n * but it turned out that OBJ does not support morphing points, which\n * is crucial for our app.\n *\n * So we had to continue using old JSONs, but, with moving to the next\n * version of JSON Geometry format, JSONLoader was first deprecated and\n * then removed from Three.js lib. Thus, we took the code from Three's\n * revision 71, when JSONLoader was still a thing. Not all the code -\n * loading file part is omitted, cause its trivial, but parsing part\n * is preserved, cause its quite complex.\n *\n * For what its worth, many thanks to https://github.com/mrdoob\n */\nexport class GeometryParser {\n  private geometry: Geometry;\n\n  private json: GeometryJSON;\n\n  // eslint-disable-next-line no-bitwise\n  private isBitSet = (value: number, position: number) => value & (1 << position);\n\n  private parseModel = (scale: number) => {\n    const {\n      faces, vertices, normals, colors,\n    } = this.json;\n    let nUvLayers = 0;\n\n    if (this.json.uvs !== undefined) {\n      for (let i = 0; i < this.json.uvs.length; i++) {\n        if (this.json.uvs[i].length) {\n          nUvLayers++;\n        }\n      }\n\n      for (let i = 0; i < nUvLayers; i++) {\n        this.geometry.faceVertexUvs[i] = [];\n      }\n    }\n\n    let offset = 0;\n    let zLength = vertices.length;\n\n    while (offset < zLength) {\n      const vertex = new Vector3();\n\n      vertex.x = vertices[offset++] * scale;\n      vertex.y = vertices[offset++] * scale;\n      vertex.z = vertices[offset++] * scale;\n\n      this.geometry.vertices.push(vertex);\n    }\n\n    offset = 0;\n    zLength = faces.length;\n\n    while (offset < zLength) {\n      const type = faces[offset++];\n\n      const isQuad = this.isBitSet(type, 0);\n      const hasMaterial = this.isBitSet(type, 1);\n      const hasFaceVertexUv = this.isBitSet(type, 3);\n      const hasFaceNormal = this.isBitSet(type, 4);\n      const hasFaceVertexNormal = this.isBitSet(type, 5);\n      const hasFaceColor = this.isBitSet(type, 6);\n      const hasFaceVertexColor = this.isBitSet(type, 7);\n\n      if (isQuad) {\n        const faceAA = faces[offset];\n        const faceAB = faces[offset + 1];\n        const faceAC = faces[offset + 3];\n        const faceA = new Face3(faceAA, faceAB, faceAC);\n\n        const faceBA = faces[offset + 1];\n        const faceBB = faces[offset + 2];\n        const faceBC = faces[offset + 3];\n        const faceB = new Face3(faceBA, faceBB, faceBC);\n\n        offset += 4;\n\n        if (hasMaterial) {\n          const materialIndex = faces[offset++];\n          faceA.materialIndex = materialIndex;\n          faceB.materialIndex = materialIndex;\n        }\n\n        const fi = this.geometry.faces.length;\n\n        if (hasFaceVertexUv) {\n          for (let i = 0; i < nUvLayers; i++) {\n            const uvLayer = (this.json.uvs as number[][])[i];\n\n            this.geometry.faceVertexUvs[i][fi] = [];\n            this.geometry.faceVertexUvs[i][fi + 1] = [];\n\n            for (let j = 0; j < 4; j++) {\n              const uvIndex = faces[offset++];\n\n              const u = uvLayer[uvIndex * 2];\n              const v = uvLayer[uvIndex * 2 + 1];\n\n              const uv = new Vector2(u, v);\n\n              if (j !== 2) {\n                this.geometry.faceVertexUvs[i][fi].push(uv);\n              }\n              if (j !== 0) {\n                this.geometry.faceVertexUvs[i][fi + 1].push(uv);\n              }\n            }\n          }\n        }\n\n        if (hasFaceNormal) {\n          let normalIndex = faces[offset++] * 3;\n\n          faceA.normal.set(\n            normals[normalIndex++],\n            normals[normalIndex++],\n            normals[normalIndex],\n          );\n\n          faceB.normal.copy(faceA.normal);\n        }\n\n        if (hasFaceVertexNormal) {\n          for (let i = 0; i < 4; i++) {\n            let normalIndex = faces[offset++] * 3;\n\n            const normal = new Vector3(\n              normals[normalIndex++],\n              normals[normalIndex++],\n              normals[normalIndex],\n            );\n\n            if (i !== 2) {\n              faceA.vertexNormals.push(normal);\n            }\n            if (i !== 0) {\n              faceB.vertexNormals.push(normal);\n            }\n          }\n        }\n\n        if (hasFaceColor) {\n          const colorIndex = faces[offset++];\n          const hex = colors[colorIndex];\n\n          faceA.color.setHex(hex);\n          faceB.color.setHex(hex);\n        }\n\n        if (hasFaceVertexColor) {\n          for (let i = 0; i < 4; i++) {\n            const colorIndex = faces[offset++];\n            const hex = colors[colorIndex];\n\n            if (i !== 2) {\n              faceA.vertexColors.push(new Color(hex));\n            }\n            if (i !== 0) {\n              faceB.vertexColors.push(new Color(hex));\n            }\n          }\n        }\n\n        this.geometry.faces.push(faceA);\n        this.geometry.faces.push(faceB);\n      } else {\n        const a = faces[offset++];\n        const b = faces[offset++];\n        const c = faces[offset++];\n        const face = new Face3(a, b, c);\n\n        if (hasMaterial) {\n          const materialIndex = faces[offset++];\n          face.materialIndex = materialIndex;\n        }\n\n        const fi = this.geometry.faces.length;\n\n        if (hasFaceVertexUv) {\n          for (let i = 0; i < nUvLayers; i++) {\n            const uvLayer = (this.json.uvs as number[][])[i];\n\n            this.geometry.faceVertexUvs[i][fi] = [];\n\n            for (let j = 0; j < 3; j++) {\n              const uvIndex = faces[offset++];\n\n              const u = uvLayer[uvIndex * 2];\n              const v = uvLayer[uvIndex * 2 + 1];\n\n              const uv = new Vector2(u, v);\n\n              this.geometry.faceVertexUvs[i][fi].push(uv);\n            }\n          }\n        }\n\n        if (hasFaceNormal) {\n          let normalIndex = faces[offset++] * 3;\n\n          face.normal.set(\n            normals[normalIndex++],\n            normals[normalIndex++],\n            normals[normalIndex],\n          );\n        }\n\n        if (hasFaceVertexNormal) {\n          for (let i = 0; i < 3; i++) {\n            let normalIndex = faces[offset++] * 3;\n\n            const normal = new Vector3(\n              normals[normalIndex++],\n              normals[normalIndex++],\n              normals[normalIndex],\n            );\n\n            face.vertexNormals.push(normal);\n          }\n        }\n\n        if (hasFaceColor) {\n          const colorIndex = faces[offset++];\n          face.color.setHex(colors[colorIndex]);\n        }\n\n        if (hasFaceVertexColor) {\n          for (let i = 0; i < 3; i++) {\n            const colorIndex = faces[offset++];\n            face.vertexColors.push(new Color(colors[colorIndex]));\n          }\n        }\n\n        this.geometry.faces.push(face);\n      }\n    }\n  };\n\n  private parseSkin = () => {\n    const influencesPerVertex = this.json.influencesPerVertex !== undefined\n      ? this.json.influencesPerVertex\n      : 2;\n\n    if (this.json.skinWeights) {\n      for (\n        let i = 0, l = this.json.skinWeights.length;\n        i < l;\n        i += influencesPerVertex\n      ) {\n        const x = this.json.skinWeights[i];\n        const y = influencesPerVertex > 1 ? this.json.skinWeights[i + 1] : 0;\n        const z = influencesPerVertex > 2 ? this.json.skinWeights[i + 2] : 0;\n        const w = influencesPerVertex > 3 ? this.json.skinWeights[i + 3] : 0;\n\n        this.geometry.skinWeights.push(new Vector4(x, y, z, w));\n      }\n    }\n\n    if (this.json.skinIndices) {\n      for (\n        let i = 0, l = this.json.skinIndices.length;\n        i < l;\n        i += influencesPerVertex\n      ) {\n        const a = this.json.skinIndices[i];\n        const b = influencesPerVertex > 1 ? this.json.skinIndices[i + 1] : 0;\n        const c = influencesPerVertex > 2 ? this.json.skinIndices[i + 2] : 0;\n        const d = influencesPerVertex > 3 ? this.json.skinIndices[i + 3] : 0;\n\n        this.geometry.skinIndices.push(new Vector4(a, b, c, d));\n      }\n    }\n\n    this.geometry.bones = this.json.bones as Bone[];\n\n    if (\n      this.geometry.bones\n      && this.geometry.bones.length > 0\n      && (this.geometry.skinWeights.length !== this.geometry.skinIndices.length\n        || this.geometry.skinIndices.length !== this.geometry.vertices.length)\n    ) {\n      console.warn(\n        `GeometryParser: When skinning, number of vertices (${this.geometry.vertices.length}), skinIndices (${this.geometry.skinIndices.length}), and skinWeights (${this.geometry.skinWeights.length}) should match.`,\n      );\n    }\n\n    this.geometry.animation = this.json.animation as AnimationClip;\n    this.geometry.animations = this.json.animations as AnimationClip[];\n  };\n\n  private parseMorphing = (scale: number) => {\n    if (this.json.morphTargets !== undefined) {\n      for (let i = 0, l = this.json.morphTargets.length; i < l; i++) {\n        this.geometry.morphTargets[i] = {\n          name: this.json.morphTargets[i].name,\n          vertices: [],\n        };\n\n        const dstVertices = this.geometry.morphTargets[i].vertices;\n        const srcVertices = this.json.morphTargets[i].vertices;\n\n        for (let v = 0, vl = srcVertices.length; v < vl; v += 3) {\n          const vertex = new Vector3();\n          vertex.x = srcVertices[v] * scale;\n          vertex.y = srcVertices[v + 1] * scale;\n          vertex.z = srcVertices[v + 2] * scale;\n\n          dstVertices.push(vertex);\n        }\n      }\n    }\n\n    // `morphColors` seem not to be part of `Geometry` anymore;\n    // it is said that we need to work with face colors instead now:\n    // https://stackoverflow.com/questions/11252592/how-to-change-face-color-in-three-js\n    // face colors, however, belong to material, not geometry,\n    // so we may need to change the whole approach\n    // todo: investigate this\n    // ----------------------------------------------------\n    // if (this.json.morphColors !== undefined) {\n    //   for (let i = 0, l = this.json.morphColors.length; i < l; i++) {\n    //     this.geometry.morphColors[i] = {};\n    //     this.geometry.morphColors[i].name = this.json.morphColors[i].name;\n    //     this.geometry.morphColors[i].colors = [];\n\n    //     const dstColors = this.geometry.morphColors[i].colors;\n    //     const srcColors = this.json.morphColors[i].colors;\n\n    //     for (let c = 0, cl = srcColors.length; c < cl; c += 3) {\n    //       const color = new Color(0xffaa00);\n    //       color.setRGB(srcColors[c], srcColors[c + 1], srcColors[c + 2]);\n    //       dstColors.push(color);\n    //     }\n    //   }\n    // }\n  };\n\n  parse = (): GeometryDescriptor => {\n    const scale = this.json.scale !== undefined ? 1.0 / this.json.scale : 1.0;\n\n    this.parseModel(scale);\n    this.parseSkin();\n    this.parseMorphing(scale);\n\n    this.geometry.computeFaceNormals();\n    this.geometry.computeBoundingSphere();\n\n    // initially, the loader handled materials as well;\n    // we should be fine without it for now, cause we use plain\n    // `MeshLambertMaterial` for all meshes anyway;\n    // todo: keep in mind that JSON contains some material info which we can use, if needed\n    // ----------------------------------------------------\n    // if (this.json.materials !== undefined && json.materials.length !== 0) {\n    //   const materials = this.initMaterials(json.materials, texturePath);\n    //   if (this.needsTangents(materials)) {\n    //     this.geometry.computeTangents();\n    //   }\n    //   return { geometry: this.geometry, materials };\n    // }\n\n    const geometry = new BufferGeometry().fromGeometry(this.geometry);\n\n    // now _this_ is my addition; I took this hack from here:\n    // https://github.com/mrdoob/three.js/issues/11277\n    // my case was slightly different: mesh had `morphTargetInfluences`\n    // initialized correctly, but updating values in it had no impact\n    // (model remained the same visually); just adding `morphTargets`\n    // to geometry somehow solves this\n    (geometry as any).morphTargets = [];\n\n    return { geometry };\n  };\n\n  constructor(json: any) {\n    this.geometry = new Geometry();\n    this.json = json;\n  }\n}\n","/* eslint-disable no-param-reassign */\nimport {\n  Scene,\n  PerspectiveCamera,\n  WebGLRenderer,\n  DirectionalLight,\n  Mesh,\n  MeshLambertMaterial,\n  TextureLoader,\n  Texture,\n  Camera,\n  Renderer,\n  Vector3,\n} from 'three';\nimport axios from 'axios';\nimport { GeometryParser } from '../../utils/geometry-parser';\nimport {\n  GingerAnimateDto,\n  GingerMorphDescriptor,\n  GingerMorphTarget,\n  GINGER_MORPH_DESCRIPTORS,\n  GINGER_MORPH_RANGES,\n} from './ginger.model';\n\nexport const getEnvironment = (): [Renderer, Scene, Camera] => {\n  const scene = new Scene();\n\n  const containerWidth = window.innerWidth;\n  const containerHeight = window.innerHeight;\n  const aspect = containerWidth / containerHeight;\n\n  const camera = new PerspectiveCamera(55, aspect, 0.1, 1000);\n  camera.position.y = 5;\n  camera.position.z = 10;\n\n  const renderer = new WebGLRenderer({\n    antialias: true,\n    preserveDrawingBuffer: true,\n  });\n  renderer.setSize(containerWidth, containerHeight);\n\n  const directionalLight = new DirectionalLight(0xffffff, 1);\n  directionalLight.position.set(0, 0, 1);\n  scene.add(directionalLight);\n\n  return [renderer, scene, camera];\n};\n\nexport const getResources = async () => {\n  const modelNames = [\n    'ginger-left-eye',\n    'ginger-right-eye',\n    'ginger-head',\n    'ginger-head-band',\n    'ginger-head-phones',\n    'ginger-teeth-top',\n    'ginger-teeth-bot',\n    'ginger-tongue',\n  ];\n  const jsonData = await Promise.all(\n    modelNames.map((modelName) => axios.get(`/model/${modelName}.json`).then(({ data }) => data)),\n  );\n\n  const meshes = jsonData.map((json, index) => {\n    const geometryParser = new GeometryParser(json);\n    const { geometry } = geometryParser.parse();\n    const material = new MeshLambertMaterial({\n      morphTargets: true,\n    });\n    const mesh = new Mesh(geometry, material);\n    mesh.name = modelNames[index];\n    return mesh;\n  });\n\n  const texture: Texture = await new TextureLoader().loadAsync(\n    '/model/ginger-color.jpg',\n  );\n  meshes.forEach((object3d) => {\n    if (object3d.name === 'ginger-head-phones') {\n      return;\n    }\n    object3d.traverse((child) => {\n      if (child instanceof Mesh) {\n        child.material.map = texture;\n      }\n    });\n  });\n\n  return meshes;\n};\n\nexport const animate = (dto: GingerAnimateDto) => {\n  const {\n    renderer, scene, camera, mousePositionRef, eyes,\n  } = dto;\n\n  const { x, y } = mousePositionRef.current;\n  const mousePositionVector = new Vector3(\n    (x / window.innerWidth) * 2 - 1,\n    -(y / window.innerHeight) * 2 + 1,\n    0.5,\n  );\n  mousePositionVector.unproject(camera);\n\n  // needed for eyes to look into camera (otherwise\n  // they are directed inside the braincase)\n  const direction = mousePositionVector.sub(camera.position).normalize();\n  direction.x *= -1;\n  direction.y *= -1;\n\n  const distance = camera.position.z / direction.z;\n  const position = camera.position\n    .clone()\n    .add(direction.multiplyScalar(distance));\n\n  eyes.forEach((eye) => {\n    eye.lookAt(position);\n\n    // needed to avoid this: https://i.imgur.com/9vaXMeF.png\n    // (in case if link don't work: eyes rolling too far)\n    eye.rotation.x /= 3;\n    eye.rotation.y /= 3;\n  });\n\n  renderer.render(scene, camera);\n\n  return requestAnimationFrame(() => {\n    animate(dto);\n  });\n};\n\nexport const getMorphValue = (\n  target: GingerMorphTarget,\n  normalizedValue: number,\n): number => {\n  const [min, max] = GINGER_MORPH_RANGES.get(target)!;\n  return (max - min) * normalizedValue + min;\n};\n\nconst handleMeshMorphing = (\n  mesh: Mesh,\n  descriptor: GingerMorphDescriptor,\n  morphValue: number,\n) => {\n  let targetIndex = -1;\n  for (let i = 0; i < descriptor.thresholds.length; i += 1) {\n    const threshold = descriptor.thresholds[i];\n    if (morphValue >= threshold) {\n      targetIndex = i;\n    }\n  }\n\n  for (let j = 0; j < descriptor.targets.length; j += 1) {\n    const index = descriptor.targets[j];\n    if (descriptor.targets[j] !== descriptor.targets[targetIndex]) {\n      // eslint-disable-next-line no-param-reassign\n      mesh.morphTargetInfluences![index] = 0;\n    } else {\n      // eslint-disable-next-line no-param-reassign\n      mesh.morphTargetInfluences![index] = Math.abs(morphValue);\n    }\n  }\n};\n\nexport const updateMorphPoints = (\n  headMesh: Mesh,\n  tongueMesh: Mesh,\n  teethBotMesh: Mesh,\n  jawHeight: number,\n  lipSync: number,\n) => {\n  // jaw height also influences position of tongue and lower teeth;\n  // tongue has its own morphing range, cause it can move independently,\n  // but teeth cannot, so for teeth we use jaw range instead\n  handleMeshMorphing(\n    headMesh,\n    GINGER_MORPH_DESCRIPTORS.get('jawHeight')!,\n    getMorphValue('jawHeight', jawHeight),\n  );\n  handleMeshMorphing(\n    tongueMesh,\n    GINGER_MORPH_DESCRIPTORS.get('tongueDown')!,\n    getMorphValue('tongue', jawHeight),\n  );\n  handleMeshMorphing(\n    teethBotMesh,\n    GINGER_MORPH_DESCRIPTORS.get('teethOpenBot')!,\n    getMorphValue('jawHeight', jawHeight),\n  );\n\n  handleMeshMorphing(\n    headMesh,\n    GINGER_MORPH_DESCRIPTORS.get('lipSync')!,\n    getMorphValue('lipSync', lipSync),\n  );\n};\n","import React, {\n  createRef, FC, useEffect, useRef, useState,\n} from 'react';\nimport { Matrix4, Mesh } from 'three';\nimport {\n  GingerProps,\n  GINGER_EYES_POSITION,\n  MousePosition,\n} from './ginger.model';\nimport {\n  animate,\n  getEnvironment,\n  getResources,\n  updateMorphPoints,\n} from './ginger.utils';\nimport './ginger.styles.css';\n\nconst GingerComponent: FC<GingerProps> = ({ morphControls }) => {\n  const rendererRef = createRef<HTMLDivElement>();\n\n  const [isLoading, setIsLoading] = useState(true);\n  const [isError, setIsError] = useState(false);\n\n  const [headMesh, setHeadMesh] = useState<Mesh>();\n  const [tongueMesh, setTongueMesh] = useState<Mesh>();\n  const [teethBotMesh, setTeethBotMesh] = useState<Mesh>();\n\n  const mousePositionRef = useRef<MousePosition>({ x: 0, y: 0 });\n\n  const animationFrameIdRef = useRef<number>();\n\n  const updateMousePosition = (event: MouseEvent) => {\n    const { clientX: x, clientY: y } = event;\n    mousePositionRef.current = { x, y };\n  };\n\n  useEffect(() => {\n    const setup = async () => {\n      const [renderer, scene, camera] = getEnvironment();\n\n      let meshes: Mesh[];\n      try {\n        meshes = await getResources();\n      } catch (e) {\n        setIsError(true);\n        return;\n      }\n\n      const [\n        leftEye,\n        rightEye,\n        head,\n        headBand,\n        headPhones,\n        teethTop,\n        teethBot,\n        tongue,\n      ] = meshes;\n\n      head.add(leftEye);\n      head.add(rightEye);\n\n      const eyes = [leftEye, rightEye];\n      eyes.forEach((eye, index) => {\n        // needed for eyes to rotate around object center\n        // (instead of world center)\n        const [x, y, z] = GINGER_EYES_POSITION[index];\n        eye.position.set(x, y, z);\n        eye.geometry.applyMatrix4(new Matrix4().makeTranslation(-x, -y, -z));\n      });\n\n      scene.add(head);\n      scene.add(headBand);\n      scene.add(headPhones);\n      scene.add(teethTop);\n      scene.add(teethBot);\n      scene.add(tongue);\n\n      rendererRef.current?.appendChild(renderer.domElement);\n\n      animationFrameIdRef.current = animate({\n        renderer,\n        scene,\n        camera,\n        eyes: [leftEye, rightEye],\n        mousePositionRef,\n      });\n\n      document.addEventListener('mousemove', updateMousePosition);\n\n      setIsLoading(false);\n\n      setHeadMesh(head);\n      setTongueMesh(tongue);\n      setTeethBotMesh(teethBot);\n    };\n\n    setup();\n\n    return () => {\n      cancelAnimationFrame(animationFrameIdRef.current!);\n      document.removeEventListener('mousemove', updateMousePosition);\n    };\n  }, []);\n\n  if (headMesh && tongueMesh && teethBotMesh) {\n    const { jawHeight, lipSync } = morphControls;\n    updateMorphPoints(headMesh, tongueMesh, teethBotMesh, jawHeight!, lipSync!);\n  }\n\n  return (\n    <>\n      <>\n        {isLoading && (\n          <div className=\"ginger-overlay ginger-pulse\">\n            <h2 className=\"heading\">Loading...</h2>\n          </div>\n        )}\n      </>\n      <>\n        {isError && (\n          <div className=\"ginger-overlay\">\n            <h2 className=\"heading\">Oops...</h2>\n            <p className=\"description\">Something went wrong.</p>\n            <p className=\"description\">Please try again later.</p>\n          </div>\n        )}\n      </>\n      <div id=\"renderer\" ref={rendererRef} />\n    </>\n  );\n};\n\nexport default GingerComponent;\n","export interface SpeechSynthesisProps {\n  onVowelSpoken: (vowel: string) => void;\n  onSpeechEnded: () => void;\n}\n\nexport interface WordDescriptor {\n  word: string;\n  clearWord: string;\n  ipaSyllables: string[];\n  timestamps: number[];\n}\n\nexport interface TextIsReadableResponse {\n  isReadable: boolean;\n  nonReadable: string[];\n}\n\nexport interface SpeechSynthesisPivot {\n  charIndex: number;\n  elapsedTime: number;\n}\n\nexport interface ExtendedSpeechSynthesisEvent extends SpeechSynthesisEvent {\n  charLength: number;\n}\n\nconst WRITTEN_VOWELS = ['a', 'e', 'i', 'o', 'u', 'y'];\n// https://www.merriam-webster.com/assets/mw/static/pdf/help/guide-to-pronunciation.pdf\nconst IPA_VOWELS = [\n  'ə',\n  'a',\n  'ā',\n  'ä',\n  'au̇',\n  'e',\n  'ē',\n  'i',\n  'ī',\n  'ō',\n  'ȯ',\n  'ȯi',\n  'ü',\n  'u̇',\n];\nexport const VOWELS = new Set([...WRITTEN_VOWELS, ...IPA_VOWELS]);\n","export default class StorageWrapper {\n  private static prefix = 'sapere-aude';\n\n  private static getKey(key: string) {\n    return `${StorageWrapper.prefix}-${key}`;\n  }\n\n  static set(key: string, value: string) {\n    localStorage.setItem(StorageWrapper.getKey(key), value);\n  }\n\n  static get(key: string) {\n    return localStorage.getItem(StorageWrapper.getKey(key));\n  }\n}\n","import axios, { AxiosResponse } from 'axios';\nimport { cloneDeep } from 'lodash';\nimport { merge, Observable, timer } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { MWDictionary } from '../../types/mw-dictionary';\nimport {\n  SpeechSynthesisPivot,\n  TextIsReadableResponse,\n  WordDescriptor,\n  ExtendedSpeechSynthesisEvent,\n  VOWELS,\n} from './speech-synthesis.model';\nimport StorageWrapper from '../../utils/storage-wrapper';\n\nconst DICTIONARY_URL = 'https://dictionaryapi.com/api/v3/references/collegiate/json';\nconst DICTIONARY_API_KEY = '32d6793f-fdbd-4861-bbfb-9d7ea4ad8625';\n\nexport const initWordDescriptors = (text: string): WordDescriptor[] => text.split(/\\s/).map((word) => ({\n  word,\n  clearWord: word.replace(/[.,/#!?$%^&*;:{}=\\-_`~()]/g, '').toLowerCase(),\n  ipaSyllables: [],\n  timestamps: [],\n}));\n\nconst getSyllablesFromDictionary = async (word: string): Promise<string[]> => {\n  let syllables: string[] = [];\n  let ipaSyllables: string[] = [];\n\n  const restoredData = StorageWrapper.get(word);\n  if (restoredData) {\n    try {\n      return JSON.parse(restoredData);\n    } catch (e) {\n      console.warn(e);\n    }\n  }\n\n  const dictionaryUrl = `${DICTIONARY_URL}/${word}?key=${DICTIONARY_API_KEY}`;\n  let response: AxiosResponse<MWDictionary.Entry[]>;\n  try {\n    response = await axios.get(dictionaryUrl);\n  } catch (e) {\n    return ipaSyllables;\n  }\n\n  if (!response || !response.data || !response.data.length) {\n    return ipaSyllables;\n  }\n\n  // the first one that has pronunciations\n  const targetIndex = response.data.findIndex(({ hwi }) => hwi?.prs?.length);\n  if (targetIndex === -1) {\n    return ipaSyllables;\n  }\n\n  const { hw, prs } = response.data[targetIndex].hwi;\n  syllables = hw.split('*');\n  if (prs && prs[0]) {\n    ipaSyllables = prs[0].mw.replace(/[()]/g, '').split('-');\n  }\n\n  if (ipaSyllables.length === 0) {\n    const headword = hw.replace('*', '');\n    // this may happen when requesting plurals:\n    // \"applications\" will not contain IPA, but \"application\" will\n    if (headword !== word) {\n      return getSyllablesFromDictionary(headword);\n    }\n    // todo: think about handling \"is\" / \"are\", \"am\" and irregular verbs\n    // (head word returned for them may be read in totally different way)\n\n    ipaSyllables = [...syllables];\n  }\n\n  StorageWrapper.set(word, JSON.stringify(ipaSyllables));\n  return ipaSyllables;\n};\n\nexport const setupSyllables = async (descriptors: WordDescriptor[]) => {\n  const nextDescriptors = cloneDeep(descriptors);\n\n  const words = nextDescriptors.map(({ clearWord }) => clearWord);\n  const uniqueWords = Array.from(new Set(words).values());\n\n  const syllablesFromDictionary = await Promise.all(\n    uniqueWords.map((word) => getSyllablesFromDictionary(word)),\n  );\n\n  nextDescriptors.forEach((descriptor) => {\n    const wordIndex = uniqueWords.indexOf(descriptor.clearWord);\n    // eslint-disable-next-line no-param-reassign\n    descriptor.ipaSyllables = [...syllablesFromDictionary[wordIndex]];\n  });\n\n  return nextDescriptors;\n};\n\nexport const getIpaVowel = (syllable: string) => {\n  if (!syllable) {\n    return '';\n  }\n\n  const matches: string[] = [];\n  VOWELS.forEach((vowel) => {\n    if (syllable.includes(vowel)) {\n      matches.push(vowel);\n    }\n  });\n\n  if (matches.length === 1) {\n    return matches[0];\n  }\n\n  // \"au̇\" has priority over \"a\", same with \"ȯi\" - \"ȯ\"\n  let maxLengthMatch = matches[0];\n  matches.forEach((match) => {\n    if (match.length > maxLengthMatch.length) {\n      maxLengthMatch = match;\n    }\n  });\n  return maxLengthMatch;\n};\n\nconst hasAllVowelsRecognized = (syllables: string[]) => syllables\n  .map((syllable) => !!getIpaVowel(syllable))\n  .reduce((acc, curr) => acc && curr, true);\nexport const isTextReadable = (\n  descriptors: WordDescriptor[],\n): TextIsReadableResponse => {\n  const nonReadable: string[] = [];\n  const isReadable = descriptors.reduce((acc, curr) => {\n    // eslint-disable-next-line operator-linebreak\n    const isCurrWordReadable =\n      !!curr.ipaSyllables.length && hasAllVowelsRecognized(curr.ipaSyllables);\n    if (!isCurrWordReadable) {\n      nonReadable.push(curr.word);\n    }\n    return acc && isCurrWordReadable;\n  }, true);\n  return {\n    isReadable,\n    nonReadable,\n  };\n};\n\nconst getVoices = async () => new Promise<SpeechSynthesisVoice[]>((resolve) => {\n  const voices = speechSynthesis.getVoices();\n  if (voices.length) {\n    resolve(voices);\n    return;\n  }\n\n  speechSynthesis.addEventListener('voiceschanged', () => resolve(speechSynthesis.getVoices()));\n});\nconst isEnglishVoice = (voice: SpeechSynthesisVoice) => ['en-US', 'en-GB'].includes(voice.lang);\nexport const getVoice = async () => {\n  const voices = await getVoices();\n\n  const ziraVoice = voices.find(({ name }) => name.includes('Zira'));\n  if (ziraVoice) {\n    return ziraVoice;\n  }\n\n  const englishFemaleVoice = voices.find(\n    (voice) => isEnglishVoice(voice)\n      && voice.name.toLocaleLowerCase().includes('female'),\n  );\n  if (englishFemaleVoice) {\n    return englishFemaleVoice;\n  }\n\n  return voices[0];\n};\n\nexport const setupElapsedTime = async (\n  descriptors: WordDescriptor[],\n  voice: SpeechSynthesisVoice,\n  rate: number,\n) => new Promise<WordDescriptor[]>((resolve) => {\n  const text = descriptors.map(({ word }) => word).join(' ');\n  const dryRunUtterance = new SpeechSynthesisUtterance(text);\n  const nextDescriptors = cloneDeep(descriptors);\n  const pivots: SpeechSynthesisPivot[] = [];\n\n  dryRunUtterance.voice = voice;\n  dryRunUtterance.volume = 0;\n  dryRunUtterance.rate = rate;\n\n  dryRunUtterance.addEventListener('boundary', (event) => {\n    const {\n      charIndex,\n      charLength,\n      elapsedTime,\n    } = event as ExtendedSpeechSynthesisEvent;\n    pivots.push({\n      charIndex: charIndex + charLength,\n      elapsedTime,\n    });\n  });\n\n  dryRunUtterance.addEventListener('end', () => {\n    const anchor = pivots[0].elapsedTime;\n    pivots.forEach((pivot) => {\n      // eslint-disable-next-line no-param-reassign\n      pivot.elapsedTime -= anchor;\n    });\n\n    nextDescriptors.forEach(({ ipaSyllables, timestamps }, index) => {\n      const wordDuration = pivots[index + 1].elapsedTime - pivots[index].elapsedTime;\n      const syllableDuration = wordDuration / ipaSyllables.length;\n      for (let i = 0; i < ipaSyllables.length; i += 1) {\n        timestamps.push(pivots[index].elapsedTime + syllableDuration * i);\n      }\n    });\n\n    return resolve(nextDescriptors);\n  });\n\n  speechSynthesis.speak(dryRunUtterance);\n});\n\nexport const formTimeline = (\n  descriptors: WordDescriptor[],\n): Observable<string> => {\n  // const allTimestamps = flatten(descriptors.map(({ timestamps }) => timestamps));\n  // const syllableDurations: number[] = allTimestamps\n  //   .map((timestamp, i) => {\n  //     if (i === 0) {\n  //       return 0;\n  //     }\n  //     return timestamp - allTimestamps[i - 1];\n  //   })\n  //   .filter((duration) => !!duration);\n  // const minSyllableDuration = Math.min(...syllableDurations);\n  // const soundDuration = Math.min(minSyllableDuration - 30, 60);\n  // const soundDuration = minSyllableDuration - 10;\n  // console.warn(soundDuration);\n\n  const observables: Observable<string>[] = [];\n\n  descriptors.forEach(({ ipaSyllables, timestamps }) => {\n    ipaSyllables.forEach((syllable, index) => {\n      observables.push(timer(timestamps[index]).pipe(map(() => syllable)));\n    });\n    // observables.push(timer(timestamps[timestamps.length - 1] + soundDuration)\n    //   .pipe(map(() => '')));\n  });\n\n  return merge(...observables);\n};\n","import React, {\n  FC,\n  useState,\n  ChangeEvent,\n  KeyboardEvent,\n  useEffect,\n} from 'react';\nimport classnames from 'classnames';\nimport { Subscription } from 'rxjs';\nimport { SpeechSynthesisProps } from './speech-synthesis.model';\nimport './speech-synthesis.styles.css';\nimport {\n  formTimeline,\n  getVoice,\n  initWordDescriptors,\n  isTextReadable,\n  setupElapsedTime,\n  setupSyllables,\n  getIpaVowel,\n} from './speech-synthesis.utils';\n\nconst SpeechSynthesisComponent: FC<SpeechSynthesisProps> = ({\n  onVowelSpoken,\n  onSpeechEnded,\n}) => {\n  const [text, setText] = useState('');\n  const [isInputTouched, setIsInputTouched] = useState(false);\n  const [isInputValid, setIsInputValid] = useState(false);\n  const [isInputDisabled, setIsInputDisabled] = useState(false);\n  const maxSymbolsAllowed = 350;\n\n  const [status, setStatus] = useState('');\n\n  const [voice, setVoice] = useState<SpeechSynthesisVoice>();\n  const speechRate = 1;\n\n  const getIsInputValid = (inputValue: string) =>\n    // eslint-disable-next-line implicit-arrow-linebreak\n    !!inputValue.length && inputValue.length <= maxSymbolsAllowed;\n\n  useEffect(() => {\n    (async () => {\n      const targetVoice = await getVoice();\n      setVoice(targetVoice);\n    })();\n  }, []);\n\n  const onTextInputChange = (event: ChangeEvent<HTMLInputElement>) => {\n    const textEntered = event.target.value;\n    setText(textEntered);\n    setIsInputTouched(true);\n    setIsInputValid(getIsInputValid(textEntered));\n    setStatus('');\n  };\n\n  const onTextInputKeyPress = async (\n    event: KeyboardEvent<HTMLInputElement>,\n  ) => {\n    if (event.key !== 'Enter' || !getIsInputValid(text)) {\n      return;\n    }\n    if (!/^[A-Za-z0-9\\s,.!?]*$/.test(text)) {\n      setStatus('In English, please!');\n      return;\n    }\n\n    let wordDescriptors = initWordDescriptors(text);\n\n    setStatus('Requesting transcription...');\n    setIsInputDisabled(true);\n    wordDescriptors = await setupSyllables(wordDescriptors);\n\n    const { isReadable, nonReadable } = isTextReadable(wordDescriptors);\n    if (!isReadable) {\n      setStatus(`Cannot recognize word \"${nonReadable[0]}\"`);\n      setIsInputDisabled(false);\n      return;\n    }\n\n    setStatus('Forming timeline...');\n    wordDescriptors = await setupElapsedTime(\n      wordDescriptors,\n      voice!,\n      speechRate,\n    );\n\n    const utterance = new SpeechSynthesisUtterance(text);\n    utterance.voice = voice!;\n    utterance.rate = speechRate;\n\n    const timeline = formTimeline(wordDescriptors);\n    const timelineSubscription = new Subscription();\n    const startTimeline = () => {\n      timelineSubscription.add(\n        timeline.subscribe((syllable) => {\n          onVowelSpoken(getIpaVowel(syllable));\n        }),\n      );\n      utterance.removeEventListener('boundary', startTimeline);\n    };\n    utterance.addEventListener('boundary', startTimeline);\n\n    const stopTimeline = () => {\n      timelineSubscription.unsubscribe();\n      utterance.removeEventListener('end', stopTimeline);\n      onSpeechEnded();\n\n      setStatus('');\n      setIsInputDisabled(false);\n    };\n    utterance.addEventListener('end', stopTimeline);\n\n    setStatus('Speaking...');\n    speechSynthesis.speak(utterance);\n  };\n\n  return (\n    <div className=\"speech-container\">\n      <input\n        className={classnames('speech-text-input', {\n          invalid: isInputTouched && !isInputValid,\n        })}\n        disabled={isInputDisabled}\n        placeholder=\"Type something and hit Enter\"\n        onChange={onTextInputChange}\n        onKeyPress={onTextInputKeyPress}\n      />\n      <span className=\"speech-status\">{status}</span>\n      <span\n        className={classnames('speech-symbols-counter', {\n          invalid: isInputTouched && !isInputValid,\n        })}\n      >\n        {text.length}\n        {' '}\n        /\n        {maxSymbolsAllowed}\n      </span>\n    </div>\n  );\n};\n\nexport default SpeechSynthesisComponent;\n","import { GingerProps } from './components/ginger/ginger.model';\n\n// eslint-disable-next-line import/prefer-default-export\nexport const MORPH_TARGETS_MAP = new Map<string, GingerProps['morphControls']>([\n  ['ə', { jawHeight: 0.3, lipSync: 0.77 }],\n  ['ē', { jawHeight: 0.13, lipSync: 0.28 }],\n  ['a', { jawHeight: 0.49, lipSync: 0.41 }],\n  ['ā', { jawHeight: 0.36, lipSync: 0.31 }],\n  ['ä', { jawHeight: 0.35, lipSync: 0.73 }],\n  ['au̇', { jawHeight: 0.47, lipSync: 0.72 }],\n  ['e', { jawHeight: 0.25, lipSync: 0.38 }],\n  ['i', { jawHeight: 0.21, lipSync: 0.46 }],\n  ['y', { jawHeight: 0.21, lipSync: 0.46 }],\n  ['ī', { jawHeight: 0.48, lipSync: 0.51 }],\n  ['ō', { jawHeight: 0.25, lipSync: 0.85 }],\n  ['ȯ', { jawHeight: 0.35, lipSync: 0.82 }],\n  ['o', { jawHeight: 0.35, lipSync: 0.82 }],\n  ['ȯi', { jawHeight: 0.34, lipSync: 0.75 }],\n  ['ü', { jawHeight: 0.16, lipSync: 0.8 }],\n  ['u̇', { jawHeight: 0.22, lipSync: 0.87 }],\n  ['u', { jawHeight: 0.22, lipSync: 0.87 }],\n]);\n","import React, { FC, useState, useCallback } from 'react';\nimport Ginger from './components/ginger/ginger.component';\nimport SpeechSynthesis from './components/speech-synthesis/speech-synthesis.component';\nimport { GingerProps } from './components/ginger/ginger.model';\nimport './app.css';\nimport { MORPH_TARGETS_MAP } from './app.model';\n\nconst AppComponent: FC = () => {\n  const initialMorphControls: GingerProps['morphControls'] = {\n    jawHeight: 0,\n    lipSync: 0.5,\n  };\n  const [morphControls, setMorphControls] = useState(initialMorphControls);\n\n  const updateMorphControls = useCallback((vowel: string) => {\n    const controls = MORPH_TARGETS_MAP.get(vowel);\n    if (!controls) {\n      console.warn(`Vowel not in map: ${vowel}`);\n      return;\n    }\n\n    setMorphControls(controls);\n  }, []);\n\n  const resetMorphControls = useCallback(() => {\n    setMorphControls(initialMorphControls);\n  }, []);\n\n  return (\n    <div className=\"app\">\n      <Ginger morphControls={morphControls} />\n      <SpeechSynthesis\n        onVowelSpoken={updateMorphControls}\n        onSpeechEnded={resetMorphControls}\n      />\n    </div>\n  );\n};\n\nexport default AppComponent;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './app';\nimport './reset.css';\nimport './index.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n"],"sourceRoot":""}